1.遇到的一个小错误

在login.html文件中引入login.css,结果要在login.css中要引入一张图片,那么该从哪个文件出发寻找这张图片的呢?从login.css出发,而不是login.html



2.踩坑:在使用layui构建登录界面时,从layui复制过来的按钮如下:

```
<button type='button' class="layui-btn layui-btn-normal layui-btn-fluid">提交</button>
```

在使用submit事件提交表单时,无论如何都不能发送ajax请求,理由就是如上代码中的type='button'是多余的,如果代码中有type='button'那么我们就得使用click事件来进行ajax请求的提交,和input[type:button]一样,复习一下表单的三种提交形式

(1)input[type:submit]这种表单提交形式有默认的表单提交行为,我们需要给form绑定submit事件,同时通过事件对象e,使用e.preventDefault()方法来阻止表单的默认提交行为

(2)button按钮,单纯的就是button按钮,没有type='button',这种表单提交形式和第一种一样,给form绑定submit事件,同时阻止表单的默认提交行为.

(3)input[type:button],这种表单的提交形式通过给button按钮绑定click点击事件,同时这种形式没有表单的默认提交行为,可以通过绑定click点击事件来提交ajax请求.





3.token的权限问题

当我们登录的时候后端会返回给我们一个token,我们需要缓存这个token,可以使用sessionStorage来进行缓存,将token值保存在sessionStorage当中,当我们进入到主页时第一件事就是判断当前token的合法性,如果当前token是合法的,那么可以进行后续的操作,如果当前token是不合法的,那么跳转回登录页面,

那如果我们伪造一个token呢?是不是也可以进入主页,理论上是的,但是在主页当中的数据我们是拿不到的,也许我们可以看到一个空的壳子,因为进入主页后如果我们要发送后续的ajax请求时,我们需要将缓存的token传递给后端进行验证,如果当前token是不合法的,那么我们是拿不到后端的数据的.





4.基于layui的表单验证功能

required是h5当中自带标签,用于表单验证,即表单项不能为空,但是layui同时也为我们提供了表单验证相关的功能,我们需要在输入域中添加一个属性lay-verify,属性值有required,phone,number,email等等,分别用于判断不同的场景,同时需要在提交按钮上绑定一个属性lay-submit属性,没有属性值.

layui的表单验证功能需要引入layui的js库,因为表单验证这里面有用到js的相关逻辑,所以需要导入layui的js库.

同时layui也支持我们自定义表单验证规则,我们需要使用layui提供的相关的api来自定义我们自己的表单验证.

```js
var form = layui.form;
form.verify({
    uname: function (value) {
        if (!/^[\S]{6,8}$/.test(value)) {
            return '请输入6-8位的字符串'
        }
    },

    pwd: function (value) {
        if (!/^[\d]{6}$/.test(value)) {
            return '密码必须是6位数字'
        }
    }
})
```

首先根据内置对象layui获取form属性,其次调用verify方法,自定义了两个匹配规则,之后将定义的匹配规则使用到输入域当中,value是输入域当中的值.

```js
<input type="text" name="username"  lay-verify="required|uname" placeholder="请输入用户名" autocomplete="off" class="layui-input"/>
```

通过|的方式定义我们所自定义的匹配规则,那么输入域当中的value必须同时符合required和uname两种匹配规则.同时除了使用函数的方式来自定义匹配规则,layui也支持数组的方式来自定义匹配规则

```js
pwd: [
        /^[\d]{6}$/, '密码必须是6位数字'
    ]
    //定义规则除了可以使用上述函数的方式也可以使用数组的方式来定义,第一个参数是要匹配的正则规则,第二个参数是如果不匹配那么需要提示的文字.这种方式更简单一点.但是如果想写复杂的规则还是需要使用函数.在函数当中可以使用多个if来定义匹配规则.
```







5.主页的布局我们采用layui的后台管理布局,将代码进行相关的更改,包括侧边栏,图片等等.以及通过lay-this来控制高亮,lay-shrink来控制收缩兄弟菜单,实现手风琴效果,添加相关的字体图标功能.以及字体图标与左边右边的间距问题.字体图标可以使用第三方的字体图标也可以使用layui自带的字体图标功能,看需求而言了.





6.我们使用iframe标签来创建子窗口,设置子窗口的高度和宽度为100%,即和父元素的宽度和高度保持一致,但是发现父元素的高度被撑开了一点,出现了垂直的滚动条?

这是因为iframe是行内元素,默认是baseline基线对齐,在iframe后面有一个看不见的空白节点,这个空白节点占据着高度,iframe默认和这个空白节点基线对齐,所以将父元素的高度撑开了一点,导致父元素出现了垂直滚动条,解决方案可以使用display将iframe变为块元素,或者使用vertical改变对齐方式都可以.注意行内元素后面的默认空白节点问题!





7.

```js
<a href="./home/dashboard.html" target="rightArea">
                            <i class="layui-icon layui-icon-home"></i>首页</a>
```

点击a链接,跳转到指定页面,同时定义在子窗口中进行打开.rightArea是子窗口的name属性值.这样可以实现同一个子窗口不同页面之间的切换.当点击左侧不同的a链接时,在同一个子窗口中进行不同页面之间的切换.







8.

```js
var baseURL = 'http://ajax.frontend.itheima.net/'
$.ajaxPrefilter(function (options) {
  
    options.url = baseURL + options.url
})
```

jquery提供了一个ajaxPrefilter方法,在发送ajax请求之前会调用该方法,做一些处理逻辑,如上述我们可以在这里拼接url地址,先设定一个基准url地址,options是发送ajax请求时所传入进来的对象.之后在发送ajax请求时,url地址我们可以简写了,前面的一长串就可以不用写,在发送请求前会调用该api,拼接成为一个完整的url地址.





9.

```js
// //获取用户基本信息,封装成为一个函数.
function loadUserInfo() {
    $.ajax({
        type: 'post',
        url: 'my/userinfo',
        headers: {
            Authorization: sessionStorage.getItem('mytoken')
        },
        success: function (res) {
            console.log(res);
        }
    })
}
loadUserInfo();
```

在主页中发送ajax请求时,需要携带请求头,jquery提供了一个headers属性,在这里可以携带请求头,Authorization值是由后端规定的.在接口文档中会提供.值就是存在sessionStorage当中的token值.success是发送请求成功的回调函数.把token传递给后端用于验证,如果验证不通过,那么后端不会传递正确的数据.





10.在发送ajax请求正确拿到数据之后,通过jquery的html()方法将数据填充到页面中,其中使用了

es6的模板字符串.可以通过status来判断是否正确拿到数据,如果拿到再进行后续的逻辑处理.判断后端传来的数据当中图片是否存在,如果存在则使用,如果不存在则使用默认的图片.同时在把数据渲染到页面中之后要进行相关样式的处理.

```js
success: function (res) {
            if (res.status === 0) {
                var userinfo = res.data;
                if (userinfo.user_pic) {
                    $('#nav-info,#header-info').html(`<div class="avatar">
                        <img src='${userinfo.user_pic}'/>
                    </div>
                    <div class="welcome">欢迎${userinfo.username}</div>`)
                }
            }
        }
```





11.但是遇到一个问题,我们用现有的样式去覆盖原来的样式,导致原来样式中一个layui基于架构自动生成的一个小图标在我们重新覆盖样式后没有了,所以header-info当中的样式不能重新进行覆盖,而是需要进行更新

```js
if (res.status === 0) {
                var userinfo = res.data;
                if (userinfo.user_pic) {
                    $('#nav-info').html(`<div class="avatar">
                        <img src='${userinfo.user_pic}'/>
                    </div>
                    <div class="welcome">欢迎${userinfo.username}</div>`);
                    $('#header-info img').attr('src', userinfo.user_pic);
                    $('#header-info span').text('欢迎'+userinfo.username)
                }
            }
```

使用attr()和text()方法在获取jquery对象后对相关内容进行更新.其实说实话能更新就更新,因为仅仅是更新的话原有layui的样式还在,不需要我们自己重新去定义样式,我们仅仅是更换了数据而已,如果是覆盖那么样式也许会被打乱.我们需要自己重新去书写相关的样式.







12.接下来就是退出流程的实现

```js
$('#logout-btn').click(function () {
    layer.confirm('你确认要退出吗?', {
        icon: 3,
        title: '提示'
    }, function (index) {
        sessionStorage.removeItem('mytoken');
        location.href = './login.html'
        layer.close(index);
    }); 
})
```

我们使用layui自带的询问功能使用户体验会更好一点,所以我们不是直接点击退出按钮就直接跳转回登录页面,而是首先会进行相关的询问,如果点击了确定,执行函数当中的代码,首先我们在退出时要移除token的值,而且要跳转回登录页面,之后关闭弹窗.







13.请求头的统一设置

```js
var baseURL = 'http://ajax.frontend.itheima.net/'
$.ajaxPrefilter(function (options) {

    options.url = baseURL + options.url;
    if (options.url !== 'api/login' && options.url !== 'api/reguser') {
        options.headers = {
            Authorization: sessionStorage.getItem('mytoken')
        }
    }
    //我们在这里统一设置请求头,因为以my开头的url路径在发送ajax请求时都要携带请求头,所以我们可以在这里进行统一的设置,当然要进行判断,因为不是所有的url路径都要携带请求头,这里除去两种特殊的情况,login和reguser,所以我们做一个判断,之后在这里统一设置headers.但是这里有bug,因为是先拼接完成之后再去进行判断,那么if分支永远都会进去,所以这是一个bug!应该调换一下位置
})
```

注意判断的逻辑使用的是&&而不是||,如果是||,两者符合一个即可,如果符合前一个,!=='api/login',那么url有可能是api/reguser,这种情况是不应该设置请求头的,所以||逻辑是不对的,注意这一点.

```js
var baseURL = 'http://ajax.frontend.itheima.net/'
$.ajaxPrefilter(function (options) {

    
    if (options.url !== 'api/login' && options.url !== 'api/reguser') {
        options.headers = {
            Authorization: sessionStorage.getItem('mytoken')
        }
    }
    //我们在这里统一设置请求头,因为以my开头的url路径在发送ajax请求时都要携带请求头,所以我们可以在这里进行统一的设置,当然要进行判断,因为不是所有的url路径都要携带请求头,这里除去两种特殊的情况,login和reguser,所以我们做一个判断,之后在这里统一设置headers.


    options.url = baseURL + options.url;
})

//这是调换位置后的,这样才是对的,应该是先判断再去进行拼接url.
```







14.统一验证token的有效性

```js
//jquery为我们提供了一个complete(),在请求发送完成后触发,不论这个请求时成功还是失败,都会触发该函数.
    options.complete = function (res) {
        if (res.responseJSON && res.responseJSON.status === 1 && res.responseJSON.message === '身份认证失败！') {
            sessionStorage.removeItem('mytoken');
            location.href = './login.html'
        }
    }
    //我们在发送ajax请求将请求头携带给后端后,后端会验证该token的合法性,如果合法,会给我们相应的数据,如果不合法,那么就会返回错误的状态.如果我们收到错误的状态,也就是代码代码当中if的判断.注意这里if的判断要严格按照返回的数据格式,我们应该删除不合法的token,并返回登录页面.
```

complete()方法可以与success()方法做一个比较,success是成功发送请求时,会执行该函数,但是complete不管请求有没有发送成功,都会执行该函数,如果我们在每一次发送ajax请求时都验证一次token的合法性,那么就会很麻烦,所以我们在ajaxPrefilter()方法中做统一验证.其实options.complete和在$.ajax()那个对象中定义一个complete方法是一样的.







15.利用jquery插件NProgress在页面头部添加进度条效果

首先在index.html当中导入NProgress的css和js库,它是依赖于jquery的,所以在导入js库的时候有前后的顺序关系,必须在jquery.js之后,另外除了complete(),jquery提供了一个beforeSend()方法,这个方法会在请求发送之前进行触发,我们在这个方法当中调用NProgress.start(),在complete()中调用NProgress.done()即可

```js
var baseURL = 'http://ajax.frontend.itheima.net/'
$.ajaxPrefilter(function (options) {
    options.beforeSend = function () {
        NProgress.start();//在请求发送前调用开始进度条
    }
    
    if (options.url !== 'api/login' && options.url !== 'api/reguser') {
        options.headers = {
            Authorization: sessionStorage.getItem('mytoken')
        }
    }
    //我们在这里统一设置请求头,因为以my开头的url路径在发送ajax请求时都要携带请求头,所以我们可以在这里进行统一的设置,当然要进行判断,因为不是所有的url路径都要携带请求头,这里除去两种特殊的情况,login和reguser,所以我们做一个判断,之后在这里统一设置headers.


    options.url = baseURL + options.url;

    //jquery为我们提供了一个complete(),在请求发送完成后触发,不论这个请求时成功还是失败,都会触发该函数.
    options.complete = function (res) {
        NProgress.done();//请求完成后调用结束进度条
        if (res.responseJSON && res.responseJSON.status === 1 && res.responseJSON.message === '身份认证失败！') {
            sessionStorage.removeItem('mytoken');
            location.href = './login.html'
        }
    }
})
```

总结一下在主页当中所做的一些处理逻辑:首先是调用了接口获取后端数据,更新图像以及后面的用户名,这是第一步,之后实现退出功能,再然后就是一些统一功能的设置,比如统一拼接url地址,统一设置请求头,统一验证token的合法性,以及最后进度条的设置,这是主页当中所进行的一些逻辑上面的设置.